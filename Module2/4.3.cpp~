#include <iostream>
#include <vector>
#include <cstdlib>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <cstdio>
#include <vector>
#include <utility>
#include <functional>
#include <stdint.h>
#include <string.h>
#include <assert.h>
#include <cmath>

template <class T>
size_t findPivotIndex(T *data, size_t start, size_t end) {
    int pivotPos = start, half = (start + end) / 2 - 1;

    if (data[start] < data[half]) {
        pivotPos = start;
        if (data[half] < data[end])
            pivotPos = half;
        else if(data[start] < data[end])
            pivotPos = end;
    } else {
        pivotPos = end;
        if (data[end] < data[half])
            pivotPos = half;
        else if (data[start] < data[end])
            pivotPos = start;
    }
    return pivotPos;
}

template <class T>
size_t Partition(T* arr, size_t begin, size_t end) {
    //Реализация стратегии выбора опорного элемента - случайный
    size_t pivotIndex = findPivotIndex(arr, begin, end);
    std::swap(arr[begin], arr[pivotIndex]);
    T pivot = arr[begin];

    //Итераторы
    size_t i = begin + 1;
    size_t j = end;

    //Hoare partition
    while (true) {
        while (i <= end && arr[i] < pivot)
            ++i;

        while (j >= begin && arr[j] > pivot)
            --j;

        if (i >= j)
            return j;

        arr[i].swap(arr[j]);
    }
}

template <class T>
size_t Partition2(T* arr, size_t begin, size_t end) {
    //Реализация стратегии выбора опорного элемента - случайный
    size_t pivotIndex = findPivotIndex(arr, begin, end);
    std::swap(arr[begin], arr[pivotIndex]);
    T pivot = arr[begin];

    size_t i = begin;     // place for swapping
    for (size_t j = begin; j < end; j++) {
        if (arr[j] <= pivot) {
            arr[i].swap(arr[j]);
            i++;
        }
    }
    arr[i].swap(arr[end]);
    return i;
}

template<class T>
void insertionSort(T *data, int left, int right) {
    for (int i = left + 1; i < right; i++) {

        int l = 0, r = i;
        T toSearch = data[i];
        while(l < r) {
            int middle = (l + r) / 2;
            if(toSearch > data[middle]) {
                l = middle + 1;
            }
            else {
                r = middle;
            }
        }

        int position = r;
        if (position < i ) {
            T temp = data[i];
            memmove(&data[position+1], &data[position], (i - position) * sizeof(T));
            data[position] = temp;
        }
    }
}
template<class T>
void insertion_sort(T *data, int left, int right) {
    for (int i = left; i < right; ++i) {
        T x = data[i];
        int j;
        for (j = i-1; j >= left && data[j] > x; --j)
            data[j+1] = data[j];
        data[j+1] = x;
    }
}

template <class T>
void quickSortIterative(T *arr, int l, int h) {
    int stack[100000];
    int top = -1;

    stack[++top] = l;
    stack[++top] = h;

    while ( top >= 0 ) {
        h = stack[ top-- ];
        l = stack[ top-- ];

        if (l >= h)
            continue;

        if (h - l <= 15000) {
            insertionSort(arr + l, 0, h - l + 1);
            continue;
        }

        int p = Partition( arr, l, h );

        if ( p - 1 > l ) {
            stack[++top] = l;
            stack[++top] = p - 1;
        }

        if ( p + 1 < h ) {
            stack[++top] = p + 1;
            stack[++top] = h;
        }
    }
}

void sort(BlackInt *begin, BlackInt *end) {
    size_t n = end - begin;
    quickSortIterative(begin, 0, n - 1);
}


